* lecture1
 主要提了eval apply循环：
 求值一个表达式的过程如下：
  1. 求值operator和operands
  2. 将operator应用于operands
* lecture2
assignment statements:赋值
1. python中name可以通过赋值和值绑定，这里的值可以是函数（e.g.f = max 此时 f 相当于 max 这个函数）；通过import导入的具有绑定的名字也可以通过赋值操作改变
2. 有的函数（如print）除了返回值之外还有副产物（比如输出一个字符串），这样的函数称为非纯函数non-pure function
3. 介绍了用户自定义函数的方式，用户自定义的函数依旧可以被赋值操作覆盖
4. 环境environment是由一系列有顺序的帧frames构成的，帧是一系列的名字和他们绑定的值
5. 应用一个函数的过程:
   1) 函数创建一个新的local frame（与一般的global frame做区分）
   2) 将输入参数的值和形式参数的名字绑定
   3) 按照函数定义开始执行
6. 帧在环境中的顺序会影响名字绑定的寻找，名字的求值根据最早找到的绑定
   *注释：可以认为后展开的frame在旧frame的下面，寻找变量的绑定从下往上找*

#+begin_src python
  from math import mul
  def sqr(sqr):
      return mul(sqr,sqr)
  sqr(-2)
#+end_src
解释：
到sqr(-2)语句之前，只存在global frame这个帧：
   其中mul是引入的名字绑定，绑定了一个函数；sqr是用户定义的函数，也绑定了一个函数
sqr(-2)这步产生了一个sqr的local frame，其中：
   sqr绑定了-2
随后在sqr这个frame中进行mul(sqr,sqr)的求值：
   求值时，mul在sqr frame中没有绑定，最终会表现为global frame中mul绑定的函数
   而sqr在sqr frame中有绑定，global frame中的sqr绑定不会影响mul(sqr,sqr)的求值

* lecture3
*注释：用elpy执行单行C-enter时，对于函数应该把光标放在定义那行后面*
1. 表达式在不同环境（或者说上下文）中的值不同
2. 就表现来看，函数创建的帧在调用完成后依然存在，见[[parent frame]]
3. 介绍了有默认值的函数定义，条件语句和迭代语句；语句称为statement，求“条件”这个bool量时，取决于上下文；条件语句不会对所有分支都求值
* lecture4
asert <predict>,<message>:如果predict为假就输出message这个字符串的报错信息（然后终止程序）
1. 上半节课讨论了condition statement特殊的求值规则：两个子句不会都被求值，不能用函数表达式模拟；and和or的断路式求值
2. 后半节课介绍了两种高阶函数的形式：
   1) 参数是函数的函数：和scheme类似不需要特殊记号
      #+begin_src python
	def summstion(n,term):
	    total,k=0,1
	    while k<=n:
	        total,k=total+term(k),k+1
	    return total

      #+end_src
   2) 返回值是函数的函数：
      #+begin_src python
	def make_adder(n):
	    def adder(k):
	        return k+n
	    return adder
	make_adder(3)(4)
	#or
	f=make_adder(3)
	f(4)
      #+end_src
*总结：高阶函数增强了我们的抽象能力*
* lecture5
1. 引入了父帧<<parent frame>>的概念:
   *函数的父帧是它被定义（不是被调用）的那个帧*
   *函数创建的帧 的父帧 是 函数的父帧*
   至此一个函数有三个概念：签名 参数 父帧
   一个帧有三个概念：帧名(唯一) 函数签名(可能重复) 父帧
   绑定值沿着一系列父帧去找
2. 从环境模型的角度解释了两种高阶函数；return能将当前帧中的的值传到父级的帧

父帧的例子：
#+begin_src python
  def square(x):
	    return x * x
	
	def successor(x):
	    return x + 1
	
	def compose1(f, g):
	    def h(x):
	        return f(g(x))
	    return h
	
	def f(x):
	    """Never called."""
	    return -x
	
	square_successor = compose1(square, successor)#
	result = square_successor(12)
#+end_src

square_successor中会调用h函数，h函数中的f,g会在h函数的父帧(#处对compose1调用而产生的帧)里去找到绑定.
因此父帧是如上定义的而不是其他方式

3. 引入lamba表达式，e.g. sqr = lambda x : x * x.这样sqr会是一个函数，而不是一个值；使用lambda 函数中不能包含语句（如while）只能是表达式
   对比：sqr = lambda x:x * x 和 def sqr几乎没有区别，唯一的区别在于函数的签名；前者函数签名是lambda(匿名)，后者就是sqr
4. 介绍了将多参函数转化为单参高阶函数的curry化
* lecture6(optional)
* lecture7
1. lambda函数的父帧是它被求值的那个帧
2. return语句会返回到上一个环境，并给出对应的值
3. 函数定义的黑箱思想
4. 语法错误和运行错误
* lecture9
1. 递归是在函数体内应用自己
2. 环境和递归：
   1) 注意def函数时，并不需要对函数求值，并不会出现函数还没用定义完（函数名还没有绑定）就需要调用函数的情况
   2) 递归过程中， *父帧并不会一直改变* （根据定义）一直是原函数定义的那个帧
3. 信仰之跃：相信自己的递归函数将会完成基本的情况；认为自己的递归函数可以处理复杂情况并在函数体中使用
4. mutal recursion:两个函数相互调用；函数在定义时不会求值，所以依旧不会报错
5. 迭代和递归：
   1) 迭代是递归的特殊情况
   2) 递归可以转迭代时，要找到状态参数
* lecture10
